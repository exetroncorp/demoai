

Perfect! Now I found the root causes. Here's what's causing the duplicate `Transfer-Encoding: chunked` headers in Spring Boot:

## The Main Culprits

### 1. **RestTemplate with ResponseEntity (Most Common)**

When using RestTemplate from a Controller and returning the result of RestTemplate.exchange() in a method that returns a ResponseEntity, if the microservice you're talking to returns a transfer-encoding header, RestTemplate.exchange will copy all response headers from the client response into the ResponseEntity it creates, including the transfer-encoding header.

Then **Tomcat adds another `Transfer-Encoding: chunked` header** on top, creating the duplicate.

**Example of problematic code:**
```java
@RestController
public class ProxyController {
    @Autowired
    private RestTemplate restTemplate;
    
    @GetMapping("/api/v1/cases")
    public ResponseEntity<?> forwardRequest() {
        // THIS IS THE PROBLEM - it copies all headers including Transfer-Encoding
        return restTemplate.exchange(url, HttpMethod.GET, request, String.class);
    }
}
```

### 2. **Embedded Tomcat Bug Under Load**

It starts happening randomly after the Spring Boot instance runs for some time, and when the specific pod is restarted, it works fine again. This problem can be reproduced only during load - for example, 300 requests will give around 3-4 errors.

Looking at proxy code, it converts received headers from API and forwards them (all headers are unique, no duplication), but the proxy's internal Tomcat is adding an additional "Transfer-Encoding" header to the response - it looks like a Tomcat bug.

### 3. **Headers Being Forwarded Through Multiple Services**

When forwarding REST responses from another service, the response already has transfer-encoding: chunked header, and while returning the same response, Spring adds transfer-encoding again.

## Solutions to Fix Spring Boot

### Solution 1: Remove Transfer-Encoding Header Before Returning
```java
@GetMapping("/api/v1/cases")
public ResponseEntity<?> forwardRequest() {
    ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, request, String.class);
    
    // Remove Transfer-Encoding header before returning
    HttpHeaders headers = new HttpHeaders();
    headers.putAll(response.getHeaders());
    headers.remove("Transfer-Encoding");
    
    return new ResponseEntity<>(response.getBody(), headers, response.getStatusCode());
}
```

### Solution 2: Use WebClient Instead of RestTemplate
With WebClient, you can return a Flux and that will trigger a streamed response (transfer-encoding chunked), and in this situation, the transfer-encoding header will only be set once.

```java
@GetMapping("/api/v1/cases")
public Mono<ResponseEntity<String>> forwardRequest() {
    return webClient.get()
        .uri(url)
        .retrieve()
        .toEntity(String.class);
}
```

### Solution 3: Switch to Jetty Instead of Tomcat
Problem solved by replacing Tomcat with Jetty embedded server - no duplicate headers, no errors.

In `pom.xml`:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

## Quick Summary

**The shit is caused by:**
1. **RestTemplate.exchange()** copying headers including Transfer-Encoding
2. **Tomcat then adds its own Transfer-Encoding header** on top
3. **Bug in Tomcat under load** that appears randomly after runtime

**Best fixes:**
1. Use **Freenginx with `proxy_allow_duplicate_chunked on;`** (nginx side - easiest)
2. Remove Transfer-Encoding header in your controller before returning (Spring side)
3. Switch from RestTemplate to WebClient (Spring side - modern approach)
4. Replace Tomcat with Jetty (Spring side - proven to work)











-------------------------------


#!/usr/bin/env python3
"""
Simple Python HTTP server that reproduces the duplicate Transfer-Encoding header issue.
This simulates the Spring Boot/Tomcat behavior that causes nginx 1.25+ to return 502 errors.

Usage:
    python3 duplicate_header_server.py

Then test with:
    curl -v http://localhost:8080/api/test
"""

from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import socket


class DuplicateHeaderHandler(BaseHTTPRequestHandler):
    
    def do_GET(self):
        """Handle GET requests with duplicate Transfer-Encoding headers"""
        
        if self.path.startswith('/api/'):
            # Prepare JSON response
            response_data = {
                "message": "This response has duplicate Transfer-Encoding headers",
                "path": self.path,
                "method": "GET",
                "status": "success"
            }
            response_body = json.dumps(response_data, indent=2).encode('utf-8')
            
            # We need to manually construct the HTTP response to send duplicate headers
            # BaseHTTPRequestHandler doesn't allow duplicate headers easily
            response_lines = [
                'HTTP/1.1 200 OK',
                'Content-Type: application/json',
                'Cache-Control: no-cache, no-store, max-age=0, must-revalidate',
                'Transfer-Encoding: chunked',
                'Transfer-Encoding: chunked',  # DUPLICATE - this causes nginx 502
                'X-Content-Type-Options: nosniff',
                'X-Frame-Options: DENY',
                'Connection: close',
                '',  # Empty line to end headers
            ]
            
            # Send raw HTTP response with duplicate headers
            raw_response = '\r\n'.join(response_lines).encode('utf-8')
            
            # Send body in chunked format (proper chunked encoding)
            chunk_size = hex(len(response_body))[2:].encode('utf-8')
            chunked_body = chunk_size + b'\r\n' + response_body + b'\r\n0\r\n\r\n'
            
            self.wfile.write(raw_response + b'\r\n' + chunked_body)
        else:
            self.send_error(404, "Not Found")
    
    def do_POST(self):
        """Handle POST requests with duplicate Transfer-Encoding headers"""
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length)
        
        response_data = {
            "message": "POST received with duplicate headers",
            "path": self.path,
            "method": "POST",
            "received_data": post_data.decode('utf-8') if post_data else None
        }
        response_body = json.dumps(response_data, indent=2).encode('utf-8')
        
        # Manually construct response with duplicate headers
        response_lines = [
            'HTTP/1.1 200 OK',
            'Content-Type: application/json',
            'Transfer-Encoding: chunked',
            'Transfer-Encoding: chunked',  # DUPLICATE
            'Connection: close',
            '',
        ]
        
        raw_response = '\r\n'.join(response_lines).encode('utf-8')
        chunk_size = hex(len(response_body))[2:].encode('utf-8')
        chunked_body = chunk_size + b'\r\n' + response_body + b'\r\n0\r\n\r\n'
        
        self.wfile.write(raw_response + b'\r\n' + chunked_body)
    
    def log_message(self, format, *args):
        """Custom logging to show what's happening"""
        print(f"[SERVER] {self.address_string()} - {format % args}")


def run_server(port=8080):
    """Run the server that produces duplicate headers"""
    server_address = ('', port)
    
    try:
        httpd = HTTPServer(server_address, DuplicateHeaderHandler)
        print(f"=" * 70)
        print(f"ðŸ”¥ DUPLICATE HEADER SERVER RUNNING ON PORT {port}")
        print(f"=" * 70)
        print(f"\nThis server intentionally sends duplicate Transfer-Encoding headers")
        print(f"to reproduce the Spring Boot/Tomcat bug that causes nginx 502 errors.\n")
        print(f"Test it with:")
        print(f"  curl -v http://localhost:{port}/api/test")
        print(f"\nOr configure your nginx to proxy to this server:")
        print(f"  proxy_pass http://localhost:{port};")
        print(f"\nTo test with nginx 1.25+, you should see 502 errors without:")
        print(f"  proxy_allow_duplicate_chunked on;")
        print(f"\nPress Ctrl+C to stop the server\n")
        print(f"=" * 70)
        
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\n\nðŸ›‘ Server stopped")
        httpd.shutdown()
    except OSError as e:
        if e.errno == 98:  # Address already in use
            print(f"\nâŒ ERROR: Port {port} is already in use!")
            print(f"Try using a different port or kill the process using port {port}")
        else:
            raise


if __name__ == '__main__':
    import sys
    
    # Allow custom port via command line
    port = 8080
    if len(sys.argv) > 1:
        try:
            port = int(sys.argv[1])
        except ValueError:
            print(f"Invalid port number: {sys.argv[1]}")
            print(f"Usage: python3 {sys.argv[0]} [port]")
            sys.exit(1)
    
    run_server(port)





-----------------FRENGINX

# 1. Remove existing nginx
sudo systemctl stop nginx
sudo apt remove nginx nginx-common -y

# 2. Install build dependencies
sudo apt install -y wget build-essential libpcre3 libpcre3-dev zlib1g zlib1g-dev libssl-dev libgd-dev libxml2 libxml2-dev uuid-dev

# 3. Download Freenginx (get latest version from https://freenginx.org/en/download.html)
# As of the mailing list you shared, version with proxy_allow_duplicate_chunked is in development
# You'll need version 1.27.x or newer when it's released
wget https://freenginx.org/download/freenginx-1.27.0.tar.gz

# 4. Extract and compile
tar -xzf freenginx-*.tar.gz
cd freenginx-*/

# 5. Configure with modules
./configure \
    --prefix=/etc/nginx \
    --sbin-path=/usr/sbin/nginx \
    --modules-path=/usr/lib/nginx/modules \
    --conf-path=/etc/nginx/nginx.conf \
    --error-log-path=/var/log/nginx/error.log \
    --http-log-path=/var/log/nginx/access.log \
    --pid-path=/var/run/nginx.pid \
    --lock-path=/var/run/nginx.lock \
    --with-http_ssl_module \
    --with-http_v2_module \
    --with-http_realip_module \
    --with-http_stub_status_module

# 6. Compile and install
make
sudo make install

# 7. Create systemd service file
sudo nano /lib/systemd/system/nginx.service





-----------------------------------------

Yes! You can download pre-compiled nginx binaries directly. Let me search for where to get them:Yes! Here's where to download nginx 1.23 binaries directly:

## Download nginx 1.23 Binary Package

Try the official nginx.org package pool directly:

```bash
# Check what's available for Ubuntu (try jammy 22.04 which had 1.23)
wget https://nginx.org/packages/ubuntu/pool/nginx/n/nginx/

# Or directly browse: http://nginx.org/packages/ubuntu/pool/nginx/n/nginx/
```

Let me check pkgs.org which archives old packages:Let me give you the direct download approach:

## Direct Download Method

**Try these direct download URLs for nginx 1.23:**

```bash
# For Ubuntu 22.04 (jammy) - 64-bit
wget http://nginx.org/packages/ubuntu/pool/nginx/n/nginx/nginx_1.23.4-1~jammy_amd64.deb

# Or try 1.23.3
wget http://nginx.org/packages/ubuntu/pool/nginx/n/nginx/nginx_1.23.3-1~jammy_amd64.deb

# Or 1.23.2
wget http://nginx.org/packages/ubuntu/pool/nginx/n/nginx/nginx_1.23.2-1~jammy_amd64.deb

# Install it
sudo dpkg -i nginx_1.23.*_amd64.deb

# Fix any dependency issues
sudo apt --fix-broken install

# Hold the version
sudo apt-mark hold nginx
```

**Alternative: Check snapshot.debian.org** (archives old packages):

```bash
# Browse old Debian/Ubuntu packages
# Visit: https://snapshot.debian.org/package/nginx/
```

**Or use pkgs.org to search and download**:
- Go to: https://pkgs.org/search/?q=nginx
- Filter by version 1.23
- Download the .deb file for your architecture

## Easiest Option: Just Copy the Binary

Since you already have nginx 1.24 installed, you could just download the nginx 1.23 **binary** directly and replace it:

```bash
# Backup current nginx
sudo cp /usr/sbin/nginx /usr/sbin/nginx.1.24.backup

# Download precompiled nginx 1.23 binary (you'd need to find a source)
# Or compile it yourself quickly:
wget https://nginx.org/download/nginx-1.23.4.tar.gz
tar -xzf nginx-1.23.4.tar.gz
cd nginx-1.23.4
./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx
make
sudo make install
```

**But honestly**, at this point you're spending more time on workarounds than it would take to just **fix Spring Boot** or **install Freenginx**. Which would you prefer?
